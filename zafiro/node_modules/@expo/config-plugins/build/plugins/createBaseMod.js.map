<<<<<<< HEAD
{"version":3,"file":"createBaseMod.js","names":["_debug","data","_interopRequireDefault","require","_withMod","obj","__esModule","default","debug","Debug","createBaseMod","methodName","platform","modName","getFilePath","read","write","isIntrospective","withUnknown","config","_props","_props$skipEmptyMod","_props$saveToInternal","props","withBaseMod","mod","skipEmptyMod","saveToInternal","isProvider","action","modRequest","nextMod","results","filePath","modResults","assertModResults","error","message","Object","defineProperty","value","platformName","ensuredResults","mods","Error","JSON","stringify","upperFirst","name","charAt","toUpperCase","slice","createPlatformBaseMod","provider","withGeneratedBaseMods","providers","entries","reduce","baseMod"],"sources":["../../src/plugins/createBaseMod.ts"],"sourcesContent":["import Debug from 'debug';\n\nimport {\n  ConfigPlugin,\n  ExportedConfig,\n  ExportedConfigWithProps,\n  ModPlatform,\n} from '../Plugin.types';\nimport { BaseModOptions, withBaseMod } from './withMod';\n\nconst debug = Debug('expo:config-plugins:base-mods');\n\nexport type ForwardedBaseModOptions = Partial<\n  Pick<BaseModOptions, 'saveToInternal' | 'skipEmptyMod'>\n>;\n\nexport type BaseModProviderMethods<\n  ModType,\n  Props extends ForwardedBaseModOptions = ForwardedBaseModOptions\n> = {\n  getFilePath: (config: ExportedConfigWithProps<ModType>, props: Props) => Promise<string> | string;\n  read: (\n    filePath: string,\n    config: ExportedConfigWithProps<ModType>,\n    props: Props\n  ) => Promise<ModType> | ModType;\n  write: (\n    filePath: string,\n    config: ExportedConfigWithProps<ModType>,\n    props: Props\n  ) => Promise<void> | void;\n  /**\n   * If the mod supports introspection, and avoids making any filesystem modifications during compilation.\n   * By enabling, this mod, and all of its descendants will be run in introspection mode.\n   * This should only be used for static files like JSON or XML, and not for application files that require regexes,\n   * or complex static files that require other files to be generated like Xcode `.pbxproj`.\n   */\n  isIntrospective?: boolean;\n};\n\nexport type CreateBaseModProps<\n  ModType,\n  Props extends ForwardedBaseModOptions = ForwardedBaseModOptions\n> = {\n  methodName: string;\n  platform: ModPlatform;\n  modName: string;\n} & BaseModProviderMethods<ModType, Props>;\n\nexport function createBaseMod<\n  ModType,\n  Props extends ForwardedBaseModOptions = ForwardedBaseModOptions\n>({\n  methodName,\n  platform,\n  modName,\n  getFilePath,\n  read,\n  write,\n  isIntrospective,\n}: CreateBaseModProps<ModType, Props>): ConfigPlugin<Props | void> {\n  const withUnknown: ConfigPlugin<Props | void> = (config, _props) => {\n    const props = _props || ({} as Props);\n    return withBaseMod<ModType>(config, {\n      platform,\n      mod: modName,\n      skipEmptyMod: props.skipEmptyMod ?? true,\n      saveToInternal: props.saveToInternal ?? false,\n      isProvider: true,\n      isIntrospective,\n      async action({ modRequest: { nextMod, ...modRequest }, ...config }) {\n        try {\n          let results: ExportedConfigWithProps<ModType> = {\n            ...config,\n            modRequest,\n          };\n\n          const filePath = await getFilePath(results, props);\n          debug(`mods.${platform}.${modName}: file path: ${filePath || '[skipped]'}`);\n          const modResults = await read(filePath, results, props);\n\n          results = await nextMod!({\n            ...results,\n            modResults,\n            modRequest,\n          });\n\n          assertModResults(results, modRequest.platform, modRequest.modName);\n\n          await write(filePath, results, props);\n          return results;\n        } catch (error: any) {\n          error.message = `[${platform}.${modName}]: ${methodName}: ${error.message}`;\n          throw error;\n        }\n      },\n    });\n  };\n\n  if (methodName) {\n    Object.defineProperty(withUnknown, 'name', {\n      value: methodName,\n    });\n  }\n\n  return withUnknown;\n}\n\nexport function assertModResults(results: any, platformName: string, modName: string) {\n  // If the results came from a mod, they'd be in the form of [config, data].\n  // Ensure the results are an array and omit the data since it should've been written by a data provider plugin.\n  const ensuredResults = results;\n\n  // Sanity check to help locate non compliant mods.\n  if (!ensuredResults || typeof ensuredResults !== 'object' || !ensuredResults?.mods) {\n    throw new Error(\n      `Mod \\`mods.${platformName}.${modName}\\` evaluated to an object that is not a valid project config. Instead got: ${JSON.stringify(\n        ensuredResults\n      )}`\n    );\n  }\n  return ensuredResults;\n}\n\nfunction upperFirst(name: string): string {\n  return name.charAt(0).toUpperCase() + name.slice(1);\n}\n\nexport function createPlatformBaseMod<\n  ModType,\n  Props extends ForwardedBaseModOptions = ForwardedBaseModOptions\n>({ modName, ...props }: Omit<CreateBaseModProps<ModType, Props>, 'methodName'>) {\n  // Generate the function name to ensure it's uniform and also to improve stack traces.\n  const methodName = `with${upperFirst(props.platform)}${upperFirst(modName)}BaseMod`;\n  return createBaseMod<ModType, Props>({\n    methodName,\n    modName,\n    ...props,\n  });\n}\n\n/** A TS wrapper for creating provides */\nexport function provider<ModType, Props extends ForwardedBaseModOptions = ForwardedBaseModOptions>(\n  props: BaseModProviderMethods<ModType, Props>\n) {\n  return props;\n}\n\n/** Plugin to create and append base mods from file providers */\nexport function withGeneratedBaseMods<ModName extends string>(\n  config: ExportedConfig,\n  {\n    platform,\n    providers,\n    ...props\n  }: ForwardedBaseModOptions & {\n    /** Officially supports `'ios' | 'android'` (`ModPlatform`). Arbitrary strings are supported for adding out-of-tree platforms. */\n    platform: ModPlatform & string;\n    providers: Partial<Record<ModName, BaseModProviderMethods<any, any>>>;\n  }\n): ExportedConfig {\n  return Object.entries(providers).reduce((config, [modName, value]) => {\n    const baseMod = createPlatformBaseMod({ platform, modName, ...(value as any) });\n    return baseMod(config, props);\n  }, config);\n}\n"],"mappings":";;;;;;;;;;AAAA,SAAAA,OAAA;EAAA,MAAAC,IAAA,GAAAC,sBAAA,CAAAC,OAAA;EAAAH,MAAA,YAAAA,CAAA;IAAA,OAAAC,IAAA;EAAA;EAAA,OAAAA,IAAA;AAAA;AAQA,SAAAG,SAAA;EAAA,MAAAH,IAAA,GAAAE,OAAA;EAAAC,QAAA,YAAAA,CAAA;IAAA,OAAAH,IAAA;EAAA;EAAA,OAAAA,IAAA;AAAA;AAAwD,SAAAC,uBAAAG,GAAA,WAAAA,GAAA,IAAAA,GAAA,CAAAC,UAAA,GAAAD,GAAA,KAAAE,OAAA,EAAAF,GAAA;AAExD,MAAMG,KAAK,GAAG,IAAAC,gBAAK,EAAC,+BAA+B,CAAC;AAuC7C,SAASC,aAAaA,CAG3B;EACAC,UAAU;EACVC,QAAQ;EACRC,OAAO;EACPC,WAAW;EACXC,IAAI;EACJC,KAAK;EACLC;AACkC,CAAC,EAA8B;EACjE,MAAMC,WAAuC,GAAGA,CAACC,MAAM,EAAEC,MAAM,KAAK;IAAA,IAAAC,mBAAA,EAAAC,qBAAA;IAClE,MAAMC,KAAK,GAAGH,MAAM,IAAK,CAAC,CAAW;IACrC,OAAO,IAAAI,sBAAW,EAAUL,MAAM,EAAE;MAClCP,QAAQ;MACRa,GAAG,EAAEZ,OAAO;MACZa,YAAY,GAAAL,mBAAA,GAAEE,KAAK,CAACG,YAAY,cAAAL,mBAAA,cAAAA,mBAAA,GAAI,IAAI;MACxCM,cAAc,GAAAL,qBAAA,GAAEC,KAAK,CAACI,cAAc,cAAAL,qBAAA,cAAAA,qBAAA,GAAI,KAAK;MAC7CM,UAAU,EAAE,IAAI;MAChBX,eAAe;MACf,MAAMY,MAAMA,CAAC;QAAEC,UAAU,EAAE;UAAEC,OAAO;UAAE,GAAGD;QAAW,CAAC;QAAE,GAAGX;MAAO,CAAC,EAAE;QAClE,IAAI;UACF,IAAIa,OAAyC,GAAG;YAC9C,GAAGb,MAAM;YACTW;UACF,CAAC;UAED,MAAMG,QAAQ,GAAG,MAAMnB,WAAW,CAACkB,OAAO,EAAET,KAAK,CAAC;UAClDf,KAAK,CAAE,QAAOI,QAAS,IAAGC,OAAQ,gBAAeoB,QAAQ,IAAI,WAAY,EAAC,CAAC;UAC3E,MAAMC,UAAU,GAAG,MAAMnB,IAAI,CAACkB,QAAQ,EAAED,OAAO,EAAET,KAAK,CAAC;UAEvDS,OAAO,GAAG,MAAMD,OAAO,CAAE;YACvB,GAAGC,OAAO;YACVE,UAAU;YACVJ;UACF,CAAC,CAAC;UAEFK,gBAAgB,CAACH,OAAO,EAAEF,UAAU,CAAClB,QAAQ,EAAEkB,UAAU,CAACjB,OAAO,CAAC;UAElE,MAAMG,KAAK,CAACiB,QAAQ,EAAED,OAAO,EAAET,KAAK,CAAC;UACrC,OAAOS,OAAO;QAChB,CAAC,CAAC,OAAOI,KAAU,EAAE;UACnBA,KAAK,CAACC,OAAO,GAAI,IAAGzB,QAAS,IAAGC,OAAQ,MAAKF,UAAW,KAAIyB,KAAK,CAACC,OAAQ,EAAC;UAC3E,MAAMD,KAAK;QACb;MACF;IACF,CAAC,CAAC;EACJ,CAAC;EAED,IAAIzB,UAAU,EAAE;IACd2B,MAAM,CAACC,cAAc,CAACrB,WAAW,EAAE,MAAM,EAAE;MACzCsB,KAAK,EAAE7B;IACT,CAAC,CAAC;EACJ;EAEA,OAAOO,WAAW;AACpB;AAEO,SAASiB,gBAAgBA,CAACH,OAAY,EAAES,YAAoB,EAAE5B,OAAe,EAAE;EACpF;EACA;EACA,MAAM6B,cAAc,GAAGV,OAAO;;EAE9B;EACA,IAAI,CAACU,cAAc,IAAI,OAAOA,cAAc,KAAK,QAAQ,IAAI,EAACA,cAAc,aAAdA,cAAc,eAAdA,cAAc,CAAEC,IAAI,GAAE;IAClF,MAAM,IAAIC,KAAK,CACZ,cAAaH,YAAa,IAAG5B,OAAQ,8EAA6EgC,IAAI,CAACC,SAAS,CAC/HJ,cAAc,CACd,EAAC,CACJ;EACH;EACA,OAAOA,cAAc;AACvB;AAEA,SAASK,UAAUA,CAACC,IAAY,EAAU;EACxC,OAAOA,IAAI,CAACC,MAAM,CAAC,CAAC,CAAC,CAACC,WAAW,EAAE,GAAGF,IAAI,CAACG,KAAK,CAAC,CAAC,CAAC;AACrD;AAEO,SAASC,qBAAqBA,CAGnC;EAAEvC,OAAO;EAAE,GAAGU;AAA8D,CAAC,EAAE;EAC/E;EACA,MAAMZ,UAAU,GAAI,OAAMoC,UAAU,CAACxB,KAAK,CAACX,QAAQ,CAAE,GAAEmC,UAAU,CAAClC,OAAO,CAAE,SAAQ;EACnF,OAAOH,aAAa,CAAiB;IACnCC,UAAU;IACVE,OAAO;IACP,GAAGU;EACL,CAAC,CAAC;AACJ;;AAEA;AACO,SAAS8B,QAAQA,CACtB9B,KAA6C,EAC7C;EACA,OAAOA,KAAK;AACd;;AAEA;AACO,SAAS+B,qBAAqBA,CACnCnC,MAAsB,EACtB;EACEP,QAAQ;EACR2C,SAAS;EACT,GAAGhC;AAKL,CAAC,EACe;EAChB,OAAOe,MAAM,CAACkB,OAAO,CAACD,SAAS,CAAC,CAACE,MAAM,CAAC,CAACtC,MAAM,EAAE,CAACN,OAAO,EAAE2B,KAAK,CAAC,KAAK;IACpE,MAAMkB,OAAO,GAAGN,qBAAqB,CAAC;MAAExC,QAAQ;MAAEC,OAAO;MAAE,GAAI2B;IAAc,CAAC,CAAC;IAC/E,OAAOkB,OAAO,CAACvC,MAAM,EAAEI,KAAK,CAAC;EAC/B,CAAC,EAAEJ,MAAM,CAAC;AACZ"}
=======
{"version":3,"sources":["../../src/plugins/createBaseMod.ts"],"names":["debug","createBaseMod","methodName","platform","modName","getFilePath","read","write","withUnknown","config","_props","props","mod","skipEmptyMod","saveToInternal","isProvider","action","modRequest","nextMod","results","filePath","modResults","assertModResults","error","message","Object","defineProperty","value","platformName","ensuredResults","mods","Error","JSON","stringify","upperFirst","name","charAt","toUpperCase","slice","createPlatformBaseMod","provider","withGeneratedBaseMods","providers","entries","reduce","baseMod"],"mappings":"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","sourcesContent":["import Debug from 'debug';\n\nimport {\n  ConfigPlugin,\n  ExportedConfig,\n  ExportedConfigWithProps,\n  ModPlatform,\n} from '../Plugin.types';\nimport { BaseModOptions, withBaseMod } from './withMod';\n\nconst debug = Debug('config-plugins:base-mods');\n\nexport type ForwardedBaseModOptions = Partial<\n  Pick<BaseModOptions, 'saveToInternal' | 'skipEmptyMod'>\n>;\n\nexport type BaseModProviderMethods<\n  ModType,\n  Props extends ForwardedBaseModOptions = ForwardedBaseModOptions\n> = {\n  getFilePath: (config: ExportedConfigWithProps<ModType>, props: Props) => Promise<string> | string;\n  read: (\n    filePath: string,\n    config: ExportedConfigWithProps<ModType>,\n    props: Props\n  ) => Promise<ModType> | ModType;\n  write: (\n    filePath: string,\n    config: ExportedConfigWithProps<ModType>,\n    props: Props\n  ) => Promise<void> | void;\n};\n\nexport type CreateBaseModProps<\n  ModType,\n  Props extends ForwardedBaseModOptions = ForwardedBaseModOptions\n> = {\n  methodName: string;\n  platform: ModPlatform;\n  modName: string;\n} & BaseModProviderMethods<ModType, Props>;\n\nexport function createBaseMod<\n  ModType,\n  Props extends ForwardedBaseModOptions = ForwardedBaseModOptions\n>({\n  methodName,\n  platform,\n  modName,\n  getFilePath,\n  read,\n  write,\n}: CreateBaseModProps<ModType, Props>): ConfigPlugin<Props | void> {\n  const withUnknown: ConfigPlugin<Props | void> = (config, _props) => {\n    const props = _props || ({} as Props);\n    return withBaseMod<ModType>(config, {\n      platform,\n      mod: modName,\n      skipEmptyMod: props.skipEmptyMod ?? true,\n      saveToInternal: props.saveToInternal ?? false,\n      isProvider: true,\n      async action({ modRequest: { nextMod, ...modRequest }, ...config }) {\n        try {\n          let results: ExportedConfigWithProps<ModType> = {\n            ...config,\n            modRequest,\n          };\n\n          const filePath = await getFilePath(results, props);\n          debug(`mods.${platform}.${modName}: file path: ${filePath || '[skipped]'}`);\n          const modResults = await read(filePath, results, props);\n\n          results = await nextMod!({\n            ...results,\n            modResults,\n            modRequest,\n          });\n\n          assertModResults(results, modRequest.platform, modRequest.modName);\n\n          await write(filePath, results, props);\n          return results;\n        } catch (error) {\n          error.message = `[${platform}.${modName}]: ${methodName}: ${error.message}`;\n          throw error;\n        }\n      },\n    });\n  };\n\n  if (methodName) {\n    Object.defineProperty(withUnknown, 'name', {\n      value: methodName,\n    });\n  }\n\n  return withUnknown;\n}\n\nexport function assertModResults(results: any, platformName: string, modName: string) {\n  // If the results came from a mod, they'd be in the form of [config, data].\n  // Ensure the results are an array and omit the data since it should've been written by a data provider plugin.\n  const ensuredResults = results;\n\n  // Sanity check to help locate non compliant mods.\n  if (!ensuredResults || typeof ensuredResults !== 'object' || !ensuredResults?.mods) {\n    throw new Error(\n      `Mod \\`mods.${platformName}.${modName}\\` evaluated to an object that is not a valid project config. Instead got: ${JSON.stringify(\n        ensuredResults\n      )}`\n    );\n  }\n  return ensuredResults;\n}\n\nfunction upperFirst(name: string): string {\n  return name.charAt(0).toUpperCase() + name.slice(1);\n}\n\nexport function createPlatformBaseMod<\n  ModType,\n  Props extends ForwardedBaseModOptions = ForwardedBaseModOptions\n>({ modName, ...props }: Omit<CreateBaseModProps<ModType, Props>, 'methodName'>) {\n  // Generate the function name to ensure it's uniform and also to improve stack traces.\n  const methodName = `with${upperFirst(props.platform)}${upperFirst(modName)}BaseMod`;\n  return createBaseMod<ModType, Props>({\n    methodName,\n    modName,\n    ...props,\n  });\n}\n\nexport function provider<ModType, Props extends ForwardedBaseModOptions = ForwardedBaseModOptions>(\n  props: BaseModProviderMethods<ModType, Props>\n) {\n  return props;\n}\n\nexport function withGeneratedBaseMods<ModName extends string>(\n  config: ExportedConfig,\n  {\n    platform,\n    providers,\n    ...props\n  }: ForwardedBaseModOptions & {\n    platform: ModPlatform;\n    providers: Partial<Record<ModName, BaseModProviderMethods<any, any>>>;\n  }\n): ExportedConfig {\n  return Object.entries(providers).reduce((config, [modName, value]) => {\n    const baseMod = createPlatformBaseMod({ platform, modName, ...(value as any) });\n    return baseMod(config, props);\n  }, config);\n}\n"],"file":"createBaseMod.js"}
>>>>>>> apetey
