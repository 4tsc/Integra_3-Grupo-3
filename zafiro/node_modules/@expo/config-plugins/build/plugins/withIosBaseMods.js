"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
<<<<<<< HEAD
exports.getIosModFileProviders = getIosModFileProviders;
exports.withIosBaseMods = withIosBaseMods;
function _jsonFile() {
  const data = _interopRequireDefault(require("@expo/json-file"));
  _jsonFile = function () {
    return data;
  };
  return data;
}
function _plist() {
  const data = _interopRequireDefault(require("@expo/plist"));
  _plist = function () {
    return data;
  };
  return data;
}
function _assert() {
  const data = _interopRequireDefault(require("assert"));
  _assert = function () {
    return data;
  };
  return data;
}
function _fs() {
  const data = _interopRequireWildcard(require("fs"));
  _fs = function () {
    return data;
  };
  return data;
}
function _path() {
  const data = _interopRequireDefault(require("path"));
  _path = function () {
    return data;
  };
  return data;
}
function _xcode() {
  const data = _interopRequireDefault(require("xcode"));
  _xcode = function () {
    return data;
  };
  return data;
}
function _ios() {
  const data = require("../ios");
  _ios = function () {
    return data;
  };
  return data;
}
function _Entitlements() {
  const data = require("../ios/Entitlements");
  _Entitlements = function () {
    return data;
  };
  return data;
}
function _Xcodeproj() {
  const data = require("../ios/utils/Xcodeproj");
  _Xcodeproj = function () {
    return data;
  };
  return data;
}
function _getInfoPlistPath() {
  const data = require("../ios/utils/getInfoPlistPath");
  _getInfoPlistPath = function () {
    return data;
  };
  return data;
}
function _modules() {
  const data = require("../utils/modules");
  _modules = function () {
    return data;
  };
  return data;
}
function _sortObject() {
  const data = require("../utils/sortObject");
  _sortObject = function () {
    return data;
  };
  return data;
}
function _warnings() {
  const data = require("../utils/warnings");
  _warnings = function () {
    return data;
  };
  return data;
}
function _createBaseMod() {
  const data = require("./createBaseMod");
  _createBaseMod = function () {
    return data;
  };
  return data;
}
function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }
function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
=======
exports.withIosBaseMods = withIosBaseMods;
exports.getIosModFileProviders = getIosModFileProviders;
exports.getIosIntrospectModFileProviders = getIosIntrospectModFileProviders;

function _plist() {
  const data = _interopRequireDefault(require("@expo/plist"));

  _plist = function () {
    return data;
  };

  return data;
}

function _assert() {
  const data = _interopRequireDefault(require("assert"));

  _assert = function () {
    return data;
  };

  return data;
}

function _fs() {
  const data = require("fs");

  _fs = function () {
    return data;
  };

  return data;
}

function _path() {
  const data = _interopRequireDefault(require("path"));

  _path = function () {
    return data;
  };

  return data;
}

function _xcode() {
  const data = _interopRequireDefault(require("xcode"));

  _xcode = function () {
    return data;
  };

  return data;
}

function _ios() {
  const data = require("../ios");

  _ios = function () {
    return data;
  };

  return data;
}

function _getInfoPlistPath() {
  const data = require("../ios/utils/getInfoPlistPath");

  _getInfoPlistPath = function () {
    return data;
  };

  return data;
}

function _modules() {
  const data = require("../utils/modules");

  _modules = function () {
    return data;
  };

  return data;
}

function _warnings() {
  const data = require("../utils/warnings");

  _warnings = function () {
    return data;
  };

  return data;
}

function _createBaseMod() {
  const data = require("./createBaseMod");

  _createBaseMod = function () {
    return data;
  };

  return data;
}

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

>>>>>>> apetey
const {
  readFile,
  writeFile
} = _fs().promises;
<<<<<<< HEAD
function getEntitlementsPlistTemplate() {
  // TODO: Fetch the versioned template file if possible
  return {};
}
function getInfoPlistTemplate() {
  // TODO: Fetch the versioned template file if possible
  return {
    CFBundleDevelopmentRegion: '$(DEVELOPMENT_LANGUAGE)',
    CFBundleExecutable: '$(EXECUTABLE_NAME)',
    CFBundleIdentifier: '$(PRODUCT_BUNDLE_IDENTIFIER)',
    CFBundleName: '$(PRODUCT_NAME)',
    CFBundlePackageType: '$(PRODUCT_BUNDLE_PACKAGE_TYPE)',
    CFBundleInfoDictionaryVersion: '6.0',
    CFBundleSignature: '????',
    LSRequiresIPhoneOS: true,
    NSAppTransportSecurity: {
      NSAllowsArbitraryLoads: true,
      NSExceptionDomains: {
        localhost: {
          NSExceptionAllowsInsecureHTTPLoads: true
        }
      }
    },
    UILaunchStoryboardName: 'SplashScreen',
    UIRequiredDeviceCapabilities: ['armv7'],
    UIViewControllerBasedStatusBarAppearance: false,
    UIStatusBarStyle: 'UIStatusBarStyleDefault',
    CADisableMinimumFrameDurationOnPhone: true
  };
}
=======

>>>>>>> apetey
const defaultProviders = {
  dangerous: (0, _createBaseMod().provider)({
    getFilePath() {
      return '';
    },
<<<<<<< HEAD
    async read() {
      return {};
    },
    async write() {}
=======

    async read() {
      return {};
    },

    async write() {}

>>>>>>> apetey
  }),
  // Append a rule to supply AppDelegate data to mods on `mods.ios.appDelegate`
  appDelegate: (0, _createBaseMod().provider)({
    getFilePath({
      modRequest: {
        projectRoot
      }
    }) {
<<<<<<< HEAD
      // TODO: Get application AppDelegate file from pbxproj.
      return _ios().Paths.getAppDelegateFilePath(projectRoot);
    },
    async read(filePath) {
      return _ios().Paths.getFileInfo(filePath);
    },
=======
      return _ios().Paths.getAppDelegateFilePath(projectRoot);
    },

    async read(filePath) {
      return _ios().Paths.getFileInfo(filePath);
    },

>>>>>>> apetey
    async write(filePath, {
      modResults: {
        contents
      }
    }) {
      await writeFile(filePath, contents);
    }
<<<<<<< HEAD
  }),
  // Append a rule to supply Expo.plist data to mods on `mods.ios.expoPlist`
  expoPlist: (0, _createBaseMod().provider)({
    isIntrospective: true,
=======

  }),
  // Append a rule to supply Expo.plist data to mods on `mods.ios.expoPlist`
  expoPlist: (0, _createBaseMod().provider)({
>>>>>>> apetey
    getFilePath({
      modRequest: {
        platformProjectRoot,
        projectName
      }
    }) {
      const supportingDirectory = _path().default.join(platformProjectRoot, projectName, 'Supporting');
<<<<<<< HEAD
      return _path().default.resolve(supportingDirectory, 'Expo.plist');
    },
    async read(filePath, {
      modRequest: {
        introspect
      }
    }) {
      try {
        return _plist().default.parse(await readFile(filePath, 'utf8'));
      } catch (error) {
        if (introspect) {
          return {};
        }
        throw error;
      }
    },
    async write(filePath, {
      modResults,
      modRequest: {
        introspect
      }
    }) {
      if (introspect) {
        return;
      }
      await writeFile(filePath, _plist().default.build((0, _sortObject().sortObject)(modResults)));
    }
=======

      return _path().default.resolve(supportingDirectory, 'Expo.plist');
    },

    async read(filePath) {
      return _plist().default.parse(await readFile(filePath, 'utf8'));
    },

    async write(filePath, {
      modResults
    }) {
      await writeFile(filePath, _plist().default.build(modResults));
    }

>>>>>>> apetey
  }),
  // Append a rule to supply .xcodeproj data to mods on `mods.ios.xcodeproj`
  xcodeproj: (0, _createBaseMod().provider)({
    getFilePath({
      modRequest: {
        projectRoot
      }
    }) {
      return _ios().Paths.getPBXProjectPath(projectRoot);
    },
<<<<<<< HEAD
    async read(filePath) {
      const project = _xcode().default.project(filePath);
      project.parseSync();
      return project;
    },
=======

    async read(filePath) {
      const project = _xcode().default.project(filePath);

      project.parseSync();
      return project;
    },

>>>>>>> apetey
    async write(filePath, {
      modResults
    }) {
      await writeFile(filePath, modResults.writeSync());
    }
<<<<<<< HEAD
  }),
  // Append a rule to supply Info.plist data to mods on `mods.ios.infoPlist`
  infoPlist: (0, _createBaseMod().provider)({
    isIntrospective: true,
    async getFilePath(config) {
      let project = null;
      try {
        project = (0, _Xcodeproj().getPbxproj)(config.modRequest.projectRoot);
      } catch {
        // noop
      }

      // Only check / warn if a project actually exists, this'll provide
      // more accurate warning messages for users in managed projects.
      if (project) {
        const infoPlistBuildProperty = (0, _getInfoPlistPath().getInfoPlistPathFromPbxproj)(project);
        if (infoPlistBuildProperty) {
          //: [root]/myapp/ios/MyApp/Info.plist
          const infoPlistPath = _path().default.join(
          //: myapp/ios
          config.modRequest.platformProjectRoot,
          //: MyApp/Info.plist
          infoPlistBuildProperty);
          if ((0, _modules().fileExists)(infoPlistPath)) {
            return infoPlistPath;
          }
          (0, _warnings().addWarningIOS)('mods.ios.infoPlist', `Info.plist file linked to Xcode project does not exist: ${infoPlistPath}`);
        } else {
          (0, _warnings().addWarningIOS)('mods.ios.infoPlist', 'Failed to find Info.plist linked to Xcode project.');
        }
      }
      try {
        // Fallback on glob...
        return await _ios().Paths.getInfoPlistPath(config.modRequest.projectRoot);
      } catch (error) {
        if (config.modRequest.introspect) {
          // fallback to an empty string in introspection mode.
          return '';
        }
        throw error;
      }
    },
=======

  }),
  // Append a rule to supply Info.plist data to mods on `mods.ios.infoPlist`
  infoPlist: (0, _createBaseMod().provider)({
    getFilePath(config) {
      const infoPlistBuildProperty = (0, _getInfoPlistPath().getInfoPlistPathFromPbxproj)(config.modRequest.projectRoot);

      if (infoPlistBuildProperty) {
        //: [root]/myapp/ios/MyApp/Info.plist
        const infoPlistPath = _path().default.join( //: myapp/ios
        config.modRequest.platformProjectRoot, //: MyApp/Info.plist
        infoPlistBuildProperty);

        if ((0, _modules().fileExists)(infoPlistPath)) {
          return infoPlistPath;
        }

        (0, _warnings().addWarningIOS)('mods.ios.infoPlist', `Info.plist file linked to Xcode project does not exist: ${infoPlistPath}`);
      } else {
        (0, _warnings().addWarningIOS)('mods.ios.infoPlist', 'Failed to find Info.plist linked to Xcode project.');
      } // Fallback on glob...


      return _ios().Paths.getInfoPlistPath(config.modRequest.projectRoot);
    },

>>>>>>> apetey
    async read(filePath, config) {
      // Apply all of the Info.plist values to the expo.ios.infoPlist object
      // TODO: Remove this in favor of just overwriting the Info.plist with the Expo object. This will enable people to actually remove values.
      if (!config.ios) config.ios = {};
      if (!config.ios.infoPlist) config.ios.infoPlist = {};
<<<<<<< HEAD
      let modResults;
      try {
        const contents = await readFile(filePath, 'utf8');
        (0, _assert().default)(contents, 'Info.plist is empty');
        modResults = _plist().default.parse(contents);
      } catch (error) {
        // Throw errors in introspection mode.
        if (!config.modRequest.introspect) {
          throw error;
        }
        // Fallback to using the infoPlist object from the Expo config.
        modResults = getInfoPlistTemplate();
      }
      config.ios.infoPlist = {
        ...(modResults || {}),
=======
      const contents = await readFile(filePath, 'utf8');
      (0, _assert().default)(contents, 'Info.plist is empty');

      const modResults = _plist().default.parse(contents);

      config.ios.infoPlist = { ...(modResults || {}),
>>>>>>> apetey
        ...config.ios.infoPlist
      };
      return config.ios.infoPlist;
    },
<<<<<<< HEAD
    async write(filePath, config) {
      // Update the contents of the static infoPlist object
      if (!config.ios) {
        config.ios = {};
      }
      config.ios.infoPlist = config.modResults;

      // Return early without writing, in introspection mode.
      if (config.modRequest.introspect) {
        return;
      }
      await writeFile(filePath, _plist().default.build((0, _sortObject().sortObject)(config.modResults)));
    }
  }),
  // Append a rule to supply .entitlements data to mods on `mods.ios.entitlements`
  entitlements: (0, _createBaseMod().provider)({
    isIntrospective: true,
    async getFilePath(config) {
      try {
        var _Entitlements$getEnti;
        (0, _Entitlements().ensureApplicationTargetEntitlementsFileConfigured)(config.modRequest.projectRoot);
        return (_Entitlements$getEnti = _ios().Entitlements.getEntitlementsPath(config.modRequest.projectRoot)) !== null && _Entitlements$getEnti !== void 0 ? _Entitlements$getEnti : '';
      } catch (error) {
        if (config.modRequest.introspect) {
          // fallback to an empty string in introspection mode.
          return '';
        }
        throw error;
      }
    },
    async read(filePath, config) {
      let modResults;
      try {
        if (!config.modRequest.ignoreExistingNativeFiles && _fs().default.existsSync(filePath)) {
          const contents = await readFile(filePath, 'utf8');
          (0, _assert().default)(contents, 'Entitlements plist is empty');
          modResults = _plist().default.parse(contents);
        } else {
          modResults = getEntitlementsPlistTemplate();
        }
      } catch (error) {
        // Throw errors in introspection mode.
        if (!config.modRequest.introspect) {
          throw error;
        }
        // Fallback to using the template file.
        modResults = getEntitlementsPlistTemplate();
      }

      // Apply all of the .entitlements values to the expo.ios.entitlements object
      // TODO: Remove this in favor of just overwriting the .entitlements with the Expo object. This will enable people to actually remove values.
      if (!config.ios) config.ios = {};
      if (!config.ios.entitlements) config.ios.entitlements = {};
      config.ios.entitlements = {
        ...(modResults || {}),
=======

    async write(filePath, config) {
      // Update the contents of the static infoPlist object
      if (!config.ios) config.ios = {};
      config.ios.infoPlist = config.modResults;
      await writeFile(filePath, _plist().default.build(config.modResults));
    }

  }),
  // Append a rule to supply .entitlements data to mods on `mods.ios.entitlements`
  entitlements: (0, _createBaseMod().provider)({
    getFilePath(config) {
      return _ios().Entitlements.getEntitlementsPath(config.modRequest.projectRoot);
    },

    async read(filePath, config) {
      const contents = await readFile(filePath, 'utf8');
      (0, _assert().default)(contents, 'Entitlements plist is empty');

      const modResults = _plist().default.parse(contents); // Apply all of the .entitlements values to the expo.ios.entitlements object
      // TODO: Remove this in favor of just overwriting the .entitlements with the Expo object. This will enable people to actually remove values.


      if (!config.ios) config.ios = {};
      if (!config.ios.entitlements) config.ios.entitlements = {};
      config.ios.entitlements = { ...(modResults || {}),
>>>>>>> apetey
        ...config.ios.entitlements
      };
      return config.ios.entitlements;
    },
<<<<<<< HEAD
=======

>>>>>>> apetey
    async write(filePath, config) {
      // Update the contents of the static entitlements object
      if (!config.ios) {
        config.ios = {};
      }
<<<<<<< HEAD
      config.ios.entitlements = config.modResults;

      // Return early without writing, in introspection mode.
      if (config.modRequest.introspect) {
        return;
      }
      await writeFile(filePath, _plist().default.build((0, _sortObject().sortObject)(config.modResults)));
    }
  }),
  // Append a rule to supply Podfile.properties.json data to mods on `mods.ios.podfileProperties`
  podfileProperties: (0, _createBaseMod().provider)({
    isIntrospective: true,
    getFilePath({
      modRequest: {
        platformProjectRoot
      }
    }) {
      return _path().default.resolve(platformProjectRoot, 'Podfile.properties.json');
    },
    async read(filePath) {
      let results = {};
      try {
        results = await _jsonFile().default.readAsync(filePath);
      } catch {}
      return results;
    },
    async write(filePath, {
      modResults,
      modRequest: {
        introspect
      }
    }) {
      if (introspect) {
        return;
      }
      await _jsonFile().default.writeAsync(filePath, modResults);
    }
  })
};
=======

      config.ios.entitlements = config.modResults;
      await writeFile(filePath, _plist().default.build(config.modResults));
    }

  })
};

>>>>>>> apetey
function withIosBaseMods(config, {
  providers,
  ...props
} = {}) {
<<<<<<< HEAD
  return (0, _createBaseMod().withGeneratedBaseMods)(config, {
    ...props,
=======
  return (0, _createBaseMod().withGeneratedBaseMods)(config, { ...props,
>>>>>>> apetey
    platform: 'ios',
    providers: providers !== null && providers !== void 0 ? providers : getIosModFileProviders()
  });
}
<<<<<<< HEAD
function getIosModFileProviders() {
  return defaultProviders;
}
=======

function getIosModFileProviders() {
  return defaultProviders;
}
/**
 * Get file providers that run introspection without modifying the actual native source code.
 * This can be used to determine the absolute static `ios.infoPlist` and `ios.entitlements` objects.
 *
 * @returns
 */


function getIosIntrospectModFileProviders() {
  const createIntrospectionProvider = (modName, {
    fallbackContents
  }) => {
    const realProvider = defaultProviders[modName];
    return (0, _createBaseMod().provider)({
      async getFilePath(...props) {
        try {
          return await realProvider.getFilePath(...props);
        } catch {
          // fallback to an empty string in introspection mode.
          return '';
        }
      },

      async read(...props) {
        try {
          return await realProvider.read(...props);
        } catch {
          // fallback if a file is missing in introspection mode.
          return fallbackContents;
        }
      },

      async write() {// write nothing in introspection mode.
      }

    });
  }; // dangerous should never be added


  return {
    // appDelegate: createIntrospectionProvider('appDelegate', {
    //   fallbackContents: {
    //     path: '',
    //     contents: '',
    //     language: 'objc',
    //   } as Paths.AppDelegateProjectFile,
    // }),
    // xcodeproj: createIntrospectionProvider('xcodeproj', {
    //   fallbackContents: {} as XcodeProject,
    // }),
    expoPlist: createIntrospectionProvider('expoPlist', {
      fallbackContents: {}
    }),
    infoPlist: {
      async getFilePath(...props) {
        try {
          return await defaultProviders.infoPlist.getFilePath(...props);
        } catch {
          return '';
        }
      },

      async read(filePath, config, props) {
        try {
          return await defaultProviders.infoPlist.read(filePath, config, props);
        } catch {
          var _config$ios$infoPlist, _config$ios;

          // Fallback to using the infoPlist object from the Expo config.
          return (_config$ios$infoPlist = (_config$ios = config.ios) === null || _config$ios === void 0 ? void 0 : _config$ios.infoPlist) !== null && _config$ios$infoPlist !== void 0 ? _config$ios$infoPlist : {
            CFBundleDevelopmentRegion: '$(DEVELOPMENT_LANGUAGE)',
            CFBundleExecutable: '$(EXECUTABLE_NAME)',
            CFBundleIdentifier: '$(PRODUCT_BUNDLE_IDENTIFIER)',
            CFBundleName: '$(PRODUCT_NAME)',
            CFBundlePackageType: '$(PRODUCT_BUNDLE_PACKAGE_TYPE)',
            CFBundleInfoDictionaryVersion: '6.0',
            CFBundleSignature: '????',
            LSRequiresIPhoneOS: true,
            NSAppTransportSecurity: {
              NSAllowsArbitraryLoads: true,
              NSExceptionDomains: {
                localhost: {
                  NSExceptionAllowsInsecureHTTPLoads: true
                }
              }
            },
            UILaunchStoryboardName: 'SplashScreen',
            UIRequiredDeviceCapabilities: ['armv7'],
            UIViewControllerBasedStatusBarAppearance: false,
            UIStatusBarStyle: 'UIStatusBarStyleDefault'
          };
        }
      },

      write(filePath, config) {
        // Update the contents of the static infoPlist object
        if (!config.ios) config.ios = {};
        config.ios.infoPlist = config.modResults;
      }

    },
    entitlements: {
      async getFilePath(...props) {
        try {
          return await defaultProviders.entitlements.getFilePath(...props);
        } catch {
          return '';
        }
      },

      async read(filePath, config, props) {
        try {
          return await defaultProviders.entitlements.read(filePath, config, props);
        } catch {
          var _config$ios$entitleme, _config$ios2;

          // Fallback to using the entitlements object from the Expo config.
          return (_config$ios$entitleme = (_config$ios2 = config.ios) === null || _config$ios2 === void 0 ? void 0 : _config$ios2.entitlements) !== null && _config$ios$entitleme !== void 0 ? _config$ios$entitleme : {};
        }
      },

      write(filePath, config) {
        // Update the contents of the static entitlements object
        if (!config.ios) config.ios = {};
        config.ios.entitlements = config.modResults;
      }

    }
  };
}
>>>>>>> apetey
//# sourceMappingURL=withIosBaseMods.js.map